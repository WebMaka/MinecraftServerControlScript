#!/bin/sh
### BEGIN INIT INFO
# Provides:       minecraft_server
# Required-Start: $remote_fs $syslog
# Required-Stop:  $remote_fs $syslog
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# chkCONFIG:      345 50 50
# Description:    Minecraft Server Control Script
### END INIT INFO

# Minecraft Server Control Script
# -----------------------------------------------------------------------------
# Originally posted by sandain on the Minecraft Forums on 9 Mar 2013. 
# Modified extensively by WebMaka (general@actiumgaming.com), et al
#
# Forum thread:
# http://www.minecraftforum.net/topic/121830-multi-world-linux-minecraft-server-control-script/
#
#
# Installing:
#
# 1. Upload this script and template.conf to a Linux server.
# 2. Pop open a terminal and paste/run these lines, one at a time:
#      sudo cp minecraft_server /etc/init.d/minecraft_server
#      sudo chmod 755 /etc/init.d/minecraft_server
#      sudo update-rc.d -f minecraft_server remove
#      sudo update-rc.d minecraft_server defaults
#      sudo adduser minecraft
#    NOTE: Obviously you'll need root for this, and when doing the adduser line leave everything
#    blank but the password - give the new user a properly strong password.
# 3. Be sure to chown the script file in /etc/init.d to the user "minecraft" (or whatever you
#    change the user to) so that it can be invoked properly.
# 4. Edit worlds.conf to add world names (essentially names for each server instance), ports, and
#    optionally IP addresses, for each server instance you want to run on the machine.
# 5. Copy template.conf and rename a copy to <world>.conf for each world entry in worlds.conf.
# 6. Edit the <world>.conf files as needed. MAKE SURE YOU SAVE EVERYTHING USING UNIX NEW-LINE
#    CONVENTIONS. Windows uses CRLFs but *NIX only uses linefeeds, and if you save this script
#    and/or any <world>.conf file using Windows CRLFs the script WILL crash and/or not work properly.
# 7. Start each server with "/etc/init.d/minecraft_server watchstart <world>" and monitor to ensure
#    everything works as desired. If all went well, great! if not, well, fix as required. ;-)
# 8. Edit the <world>.conf files again if necessary/desired to optimize Java start parameters, improve
#    performance, etc.
#
#
# Commands:
#
# NOTE: When [<world>] is the parameter, the command will work on/for the server for the given <world>,
# or all CONFIGured servers if no world is specified. Nevertheless, a few commands are world-specific.
#
#  start [<world>]: Start the server for instance <world>, or start all server instances.
#  watchstart <world>: Start the server, and switch to its screen to see the startup process in real time.
#  stop [<world>]: Stop the server.
#  force-stop [<world>]: Kill the server's running process.
#  restart [<world>]: Stop and restart the server.
#  force-restart [<world>]: Kill the server's running process and restart the server.
#  scheduled-restart <world>: Stop and restart the server, giving warnings as far as 10 minutes in 
#    advance. (Intended to be auto-fired on a regular basis via cron, etc.)
#  powercycle [<world>]: Stop, back up, and restart the server. (NOTE: Backs up only the world files - 
#    essentially this combines "restart" and "backup".
#  status [<world>]: View the server's current status (running or not), and player count if applicable.
#  sync [<world>]: Sync the server's world files to the . files on disk if mirroring is enabled.
#  send <world> <command>: Send a single <command> to the server. Anything sent as <command> is 
#    essentially run as a console command, so use with caution.
#  screen <world>: Switch to the server's screen.
#  watch <world>: Monitor the server by watching for server log changes. This basically only displays 
#    major events - use "screen" to watch minor events, mod messages, and debugging information.
#  logrotate [<world>]: Rotate the server's log files.
#  savetodisk [<world>]: Flush all pending world updates to disk - includes "sync" functionality if
#    mirroring is enabled.
#  backup [<world>]: Back up the server's world files. NOTE: This can take several minutes and can slowly 
#    consume a lot of disk space over time.
#  fullbackup [<world>]: Back up the entire server. NOTE: This can take half an hour or more and will eat
#    a lot of disk space.
#  map [<world>]: Redo the Overviewer map for the server, if Overviewer is installed.
#
#
# Suggestions:
#
# - Once you're sure a newly added server is working properly, use the "fullbackup" command with
#   tarball creation enabled to create an easy-to-reinstall copy in case something blows up.
# - Add a cron task to run the "savetodisk" command on regular intervals. 15-30 minutes is good for
#   non-mirrored servers, but go with 5-10 minute intervals for mirrored so data loss risks are
#   reduced.
# - Add a cron task to run the "backup" command on regular intervals to archive each server's world
#   files. 6-24 hours is about right, but beware of disk space usage if you enable tarball creation
#   and have a short interval; 6-hour backup intervals can make a terabyte of space vanish in a
#   month unless you change the BACKUP_DURATION value to something reasonable!
# - For really mod-heavy servers (e.g., Tekkit, Feed the Beast) it might not be a bad idea to add a
#   cron task to run the "scheduled-restart" command to stop and restart the server. This is a good
#   idea because large amounts of mods can make Java leak so much memory it becomes slow and unstable
#   after a couple days. Usually, restarting such servers once a day during the lowest-traffic part
#   of the day is fine.
#
#
# Change Log:
#
# - fix the detection of required programs.  Error messages should now display correctly 
#   if a program is found to be missing.
# - fix the permissions for the screen tty using Montoya's patch.
# - Add the logrotate command to the script for rotating the log file using a modified version 
#   of Zanix's patch.
# - Search the world folder for an overviewer-settings.py file for custom mapping settings for 
#   the world using Zanix's patch.
# - Use the update infrastructure to manage the Minecraft client download using Zanix's patch.
# - Catch banned players logging off of the server using Zanix's patch.
# - Add support for Minecraft Overviewer and drop support for c10t and Pigmap.
# - Remove support for mcsuperserver.py, it is buggy and does not have an update for Minecraft 1.4.
# - Remove support for user and admin commands.  They no longer work with Minecraft 1.4.
# - Use Paul Andreassen's mcsuperserver.py to launch servers on demand as recommend by Culfri.
# - Add support for the Pigmap mapping software.
# - Added Zanix's backup patch.
# - Add a more descriptive error for when the server fails to start.
# - fix an issue with wget not being able to download CraftBukkit at its current address (was 
#   breaking on the &).
# - Once again update the CraftBukkit download location to point to their latest release.
# - Add a separate variable for admin level user commands, but just give them access to the motd for now.
# - Recognise admins attempting to run a command.
# - Update the CraftBukkit download location to point to their latest stable build (fixes 1.0).
# - Add an IP address field to the worlds.conf file, blank by default.
# - Add the option to utilize a mirror image of a world for use in ramdisk configurations.
# - Modify init info to include support for chkCONFIG.
# - Add a lock file when running under RedHat/CentOS to fix shutdown issues (found by swallowtail23).
# - Display a message prior to displaying a world's screen about how to exit that screen.
# - fix a bug in detecting the process ID of Screen when there are very similar world names (found by 
#   Tachdelan).
# - fix mapping of the Nether when using CraftBukkit.
# - Update the CraftBukkit download location to point to their latest stable build (fixes beta 1.8).
# - Simplify the server type selection code as suggest by hexparrot.
# - Verify the download of c10t.
# - Add /help and /motd user commands.
# - Follow symbolic links when creating tar archives during a full backup.
# - Make the auto restart on SEVERE server event optional.
# - Simplify the Nether detection method, fixing the mapping of the Nether in 1.6.
# - Print a message if running the script as the wrong user.
# - Add current version detection for c10t download.
# - fix c10t download.
# - Add support for CraftBukkit.
# - Add an option to connect to the Screen holding the world's console.
# - Restart the server when a SEVERE server event is caught.
# - fix mapping of Nether worlds with c10t.ftb_ultimate
# - Allow spaces in addition to tabs in the worlds.conf file.
# - Allow the script to run from a user account.
# - Add the watch command line option to allow the server admin to watch the log file.
# - Add options to route lib-notify output to the correct user and display.
# - Make sure the server.log file exists prior to starting the log processor.
# - Allow comments in the worlds.conf file.
# - Be more verbose when doing updates to the server software.
# - Add a Message of the Day (MOTD) that is whispered to users when they log on.
# - fix lib-notify output.
# - Remove the time from backup files, instead use a counter for multiple backups in the same day.  This 
#   should fix issues with file systems that don't like using a colon in the filename.
# - Output the number of online users when the scripts status command is given.
# - fix 32/64 bit detection (used for updating c10t).
# - Add initial log processing.  Keep track of users logging in and out.
# - Make the script use the same world names as Minecraft.
# - Add error checking to calls to wget and screen.
# - Add backup duration variable and logic.  Backups older than X days are now removed when new 
#   backups are created.
# - Directories are now created properly when maps are first created with c10t.
# - Add send option, to send a command to the world server.
# - Add an infrastructure for updating addons, and add c10t to the update routine.
# - Add force-stop and force-restart options to kill a world server process after attempting a clean
#   shutdown.  This will allow admins to stop locked servers more easily.
#
# Changes made by WebMaka during May-June 2013:
# - Changed the launch code to place server-centric configurations in separate files for each 
#   instance. This permits the script to manage multiple servers with different jar files and
#   their own special sets of Java startup parameters.
# - Added sanity checking and autocreate-if-missing for world configuration files.
# - Modified the mirroring code to mirror world files only, auto-creating and removing symlinks
#   and renaming the original world file directory as needed. Mirroring is also per-server, and
#   can be enabled or disabled within each server's config file.
# - Re-added tarball creation to the script's backup options. When enabled, the script can back 
#   up the world files or whole server instance to a .tar.gz archive file. This can be used in 
#   conjunction with rdiff-backup to provide both incremental mirrored backups AND downloadable,
#   offsite-storable archives.
# - Made script responses more verbose/useful, and added some basic formatting to them. Piping
#   script execution results to text files for later examination can actually be useful now.
# - Added "powercycle" command, which combines "restart" and "backup" to stop the server, back up its
#   world files, and then restart the server.
# - Added "scheduled-restart" command, which is basically "restart" with warnings at 10 and 5 minutes
#   before shutdown as well as 60, 30, 15, 10, and 5 seconds before. This command is intended to be 
#   "cronned" to auto-restart servers on a regular basis when they require it in order to maintain
#   stability.
# - Added "watchstart" command, which combines "start" with "screen" to start the server and jump right
#   into its startup process. Wonderful for seeing what's doing what during startup.
# - Added "savetodisk" command, which expands on the "sync" command to save pending world file updates
#   to disk, including mirrored world files which are then copied to disk.
# - Edited all server stop/restart commands to give warnings at 60, 30, 15, 10, and 5 seconds before 
#   dropping the server. Gives more time for players to panic and complain before the server stops. ;-)
# - Cleaned up a lot of the comment text, revamped descriptions, etc. to make things a bit clearer.



# User Account & Server Root
# --------------------------
# Who we run as and where we run from.

# User name used to run all commands. Be sure to create this user (sudo adduser minecraft) if it 
# doesn't already exist.
USER_NAME="minecraft"

# The location of server software and data.
LOCATION="/home/$USER_NAME/actium_minecraft_server"



# Required Software
# -----------------
# Detect its presence and location for later.

JAVA=$(which java)
PERL=$(which perl)
PYTHON=$(which python)
RSYNC=$(which rsync)
SCREEN=$(which screen)
WGET=$(which wget)
RDIFF_BACKUP=$(which rdiff-backup)
TAR=$(which tar)



# Global Server Configuration
# ---------------------------

# Automatically restart the Minecraft server when a SEVERE error is caught.
#
# 0 - Do not automatically restart when a SEVERE error is caught. Let it crash and stop.
# 1 - Automatically restart the server on a SEVERE error.
AUTO_RESTART_ON_ERROR=0

# Where the server jars are stored
SERVER_LOCATION="$LOCATION/minecraft_server"



# Minecraft Client Settings
# -------------------------

# Client location (needed for Minecraft Overviewer, which is optional).
CLIENT_JAR="minecraft.jar"
CLIENT_URL="https://s3.amazonaws.com/MinecraftDownload/minecraft.jar"
CLIENT_LOCATION="$LOCATION/.minecraft/bin"



# World (Server Instance) Configuration
# -------------------------------------

# The location to store files for each world server.
WORLDS_LOCATION="$LOCATION/worlds"

# List of worlds and the ports they are running on.  This file will
# be generated if missing.
#
# Note: The world name should not contain a space.  Leave the ip
# address blank if not needed.
#
# # Minecraft world Configuration file
# # <world>	<port>	<ip>
#   alpha       25565
#   beta	25566
#   gamma	25567
#   delta	25568
#   epsilon	25569
WORLDS_CONF="$LOCATION/worlds.conf"

# Default world name, port, and IP address if the worlds.conf file is missing.
DEFAULT_WORLD="world"
DEFAULT_PORT="25565"
DEFAULT_IP=""



# Global Message Of The Day file (MOTD)
# -------------------------------------

# Location of the file to display to users on login.  Nothing will be done if
# this file does not exist.
MOTD="$LOCATION/motd.txt"

# NOTE: MOTD can contain color codes as follows:
#  §0 - black
#  §1 - blue
#  §2 - dark green
#  §3 - aqua
#  §4 - dark red
#  §5 - purple
#  §6 - gold
#  §7 - gray
#  §8 - dark gray
#  §9 - light blue
#  §a - green
#  §b - teal
#  §c - red
#  §d - magenta
#  §e - yellow
#  §f - white



# Backup Configuration
# --------------------

# Tarball creation - when enabled, backup .tar.gz archive files will be created
# by the "backup" and "fullbackup" commands.
#
# 0 - Do not make tarballs when backing up.
# 1 - Create tarballs (.tar.gz archive files) as backups.
ENABLE_TARBALLING=1

# rdiff-backup - when enabled, an incremental mirror of the world files or whole
# server will be created by the "backup" and "fullbackup" commands.
#
# 0 - Do not use rdiff-backup to make an incremental-mirror backup.
# 1 - Use rdiff-backup.
ENABLE_RDIFF=1

# Location to store backups.
BACKUP_LOCATION="$LOCATION/backups"

# Location of the backup log file.
BACKUP_LOG="$BACKUP_LOCATION/backup.log"

# Length in days that backups survive.
BACKUP_DURATION=15
	  
	  

# Server Log Configuration
# ------------------------

# How many rotations of server.log to keep
LOG_COUNT=10


# Mirroring Options0
# -----------------

# Create a mirror image of the world data on system startup, and
# update that mirror image on system shutdown.
#
# IMPORTANT: if using this option, the admin should schedule
# periodic synchronizations of the mirror image using cron
# to avoid data loss. To do this, add a cron task to call 
# either "savetodisk" or "sync" on a VERY regular basis (e.g.,
# every 5-10 minutes).
#
# 0 - Do not use a mirror image, default.
# 1 - Use a mirror image.
#ENABLE_MIRROR=0
# NOTE: Moved to per-server configuration!

# The location to store the mirror image.
#
# NOTE: This is usually a ramdisk, e.g. /dev/shm on Debian/Ubuntu.
MIRROR_PATH="/dev/shm/minecraft"



# Mincecraft Overviewer Mapping Software Options
# ----------------------------------------------

OVERVIEWER_BIN=$(which overviewer.py)
MAPS_URL="http://minecraft.server.com/maps"
MAPS_LOCATION="$LOCATION/maps"



# Lib-Notify Configuration
# ------------------------

# Use lib-notify to print a message on your desktop of important server events.
# 0 - Do not use lib-notify.
# 1 - Display server events using lib-notify.
USE_LIBNOTIFY=0

# The username and display that messages will be routed to.
LIBNOTIFY_USER_NAME=$USER_NAME
LIBNOTIFY_DISPLAY=":0.0"



# Internal Methods
# ----------------
#
# NOTE: Nothing below this point should need to be edited directly.
#

# Execute the given command.
#
# @param 1 The command to execute.
# @param 2 The user name to execute the command with.
execute() {
	if [ $(id -u) -eq 0 ]; then
		# Script is running as root, switch user and execute
		# the command.
		su -c "$1" $2
	else
		# Script is running as a user, just execute the command.
		sh -c "$1"
	fi
}

# Get the PIDs of the Screen and Java process for the world server.
#
# @param 1 The world server of interest.
# @return The Screen and Java PIDs
getProcessIDs() {
	local SCREEN_PID JAVA_PID
	SCREEN_PID=$(execute "$SCREEN -ls" $USER_NAME | $PERL -ne 'if ($_ =~ /^\t(\d+)\.minecraft-'$1'\s+/) { print $1; }')
	JAVA_PID=$(ps -a -u $USER_NAME -o pid,ppid,comm | $PERL -ne 'if ($_ =~ /^\s*(\d+)\s+'$SCREEN_PID'\s+java/) { print $1; }')
	echo "$SCREEN_PID $JAVA_PID"
}

# Check to see if the world server is running.
#
# @param 1 The world server of interest.
# @return A 1 if the server is thought to be running, a 0 otherwise.
serverRunning() {
	local PIDS
	PIDS=$(getProcessIDs $1)
	# Try to determine if the world is running.
	if [ -n "$(echo $PIDS | cut -d ' ' -f1)" ] && [ -n "$(echo $PIDS | cut -d ' ' -f2)" ]; then
		echo 1
	else
		echo 0
	fi
}

# Send a command to the world server.
#
# @param 1 The world server of interest.
# @param 2 The command to send.
sendCommand() {
	local COMMAND PID
	COMMAND=$(printf "$2\r")
	PID=$(echo $(getProcessIDs $1) | cut -d ' ' -f1)
	execute "$SCREEN -S $PID.minecraft-$1 -p 0 -X stuff \"$COMMAND\"" $USER_NAME
	if [ $? -ne 0 ]; then
		printf "Error sending command to server $1.\n"
		exit 1
	fi
}

# Connect to the Screen of a world server.
#
# @param 1 The world server of interest.
displayScreen() {
	local PID
	PID=$(echo $(getProcessIDs $1) | cut -d ' ' -f1)
	chmod o+rw  $(tty)
	execute "$SCREEN -x $PID.minecraft-$1" $USER_NAME
	if [ $? -ne 0 ]; then
		printf "Error connecting to Screen.\n"
		chmod o-rw  $(tty)
		exit 1
	fi
	chmod o-rw  $(tty)
}

# Check whether the item is in the list.
#
# @param 1 The item being searched for.
# @param 2 The list being searched.
# @return A 1 if the list contains the item, a 0 otherwise.
listContains() {
	local MATCH ITEM
	MATCH=0
	for ITEM in $2; do
		if [ "$ITEM" = "$1" ]; then
			MATCH=1
		fi
	done
	echo $MATCH
}

# Grab the port for the given world.
#
# @param 1 The world server of interest.
# @return The port that the world is CONFIGured to use.
getPort() {
	local PORT
	PORT=$(execute "cat $WORLDS_CONF" $USER_NAME | $PERL -ne 'if ($_ =~ /^'$1'\s+(\d+)/) { print "$1"; }')
	echo $PORT
}

# Grab the IP address for the given world.
#
# @param 1 The world server of interest.
# @return The IP address that the world is CONFIGured to run on.
getIP() {
	local IP
	IP=$(execute "cat $WORLDS_CONF" $USER_NAME | $PERL -ne 'if ($_ =~ /^'$1'\s+\d+\s+([\d\.]+)/) { print "$1"; }')
	echo $IP
}

# Grab the first line of the Message of the Day file as a summequivalentary, and strip
# any color codes from it.
getMOTD() {
	local MOTD_SUMMARY
	MOTD_SUMMARY=""
	if [ -e "$MOTD" ]; then
		MOTD_SUMMARY=$(head -n 1 $MOTD | $PERL -ne '$_ =~ s/§[0-9a-fA-F]//g; print;')
	fi
	echo $MOTD_SUMMARY
}

# Grab the list of worlds.
#
# @return The list of worlds.
getWorlds() {
	local WORLDS
	WORLDS=$(execute "cat $WORLDS_CONF" $USER_NAME | $PERL -ne 'if ($_ =~ /^(\w+)\s+(\d+)/) { print "$1 "; }')
	echo $WORLDS
}

# Modify the value of a key/value combo in a properties file.
#
# @param 1 The properties file of interest.
# @param 2 The key to modify.
# @param 3 The value to assign to the key.
setPropertiesValue() {
	local KEY_VALUE
	# Make sure that the properties file exists.
	execute "touch $1" $USER_NAME

	# Replace the key/value combo if it already exists, otherwise just
	# append it to the end of the file.
	KEY_VALUE=$($PERL -ne 'if ($_ =~ /^('$2'=.*)$/) { print "$1"; }' $1)
	if [ -n "$KEY_VALUE" ]; then
		execute "$PERL -i -ne 'if (\$_ =~ /^$2=.*$/) { print \"$2=$3\\n\"; } else { print; }' $1" $USER_NAME
	else
		execute "printf \"$2=$3\\n\" >> $1" $USER_NAME
	fi
}

# Send a message to the desktop using lib-notify, if it is available.
#
# @param 1 The summary of the message to send.
# @param 2 The body of the message to send.
libNotify() {
	local NOTIFY
	NOTIFY=$(which notify-send)
	if [ -e "$NOTIFY" ]; then
		execute "DISPLAY=$LIBNOTIFY_DISPLAY $NOTIFY \"$1\" \"$2\"" $LIBNOTIFY_USER_NAME > /dev/null 2>&1
	fi
}

# Send the contents of the Message Of The Day (MOTD) to the user.
#
# @param 1 The world server of interest.
# @param 2 The user being told the contents of the motd file.
tellMOTD() {
	local LINE
	if [ -e "$MOTD" ]; then
		while read LINE; do
			sendCommand $1 "tell $2 $LINE"
		done < $MOTD
	fi
}

# Check to see if the user is in the ops.txt file of the specified world.
#
# @param 1 The world server of interest.
# @param 2 The user being checked.
checkUserIsAdmin() {
	local IS_ADMIN
	IS_ADMIN=$(cat $WORLDS_LOCATION/$1/ops.txt | $PERL -ne 'if ($_ =~ /^'$2'$/i) { print "1"; }')
	echo $IS_ADMIN
}

# Check for the optional argument.  if the argument is not supplied, return
# the original list.  if the argument is supplied, verify that it is a member
# of the list, then modify the list to just contain that member.
#
# @param 1 The original list.
# @param 2 The name of the script.
# @param 3 The command line argument used.
# @param 4 The optional command line argument.
# @return Either the original list, or the optional command line argument.
checkOptionalArgument() {
	local LIST
	LIST="$1"

	# Check for the optional command line argument.
	if [ -n "$4"  ] && [ $(listContains $4 "$1") -eq 1 ]; then
		LIST="$4"
	elif [ -n "$4" ]; then
		printf "Optional argument '$4' not recognized.\n"
		printf "  Usage:  $2 $3 <optional argument>\n"
		exit 1
	fi
	echo "$LIST"
}

# Check for users logging into a world.  if a user logs in, perform
# login functions.
#
# @param 1 The world server of interest.
# @param 2 The message to check for users logging in.
checkForLogin() {
	local LOGIN PLAYER_NAME
	LOGIN=$(echo "$2" | $PERL -ne 'if ($_ =~ /(\w+)\s*\[\/([0-9\.]+)\:(\d+)\] logged in with entity id (\d+)/) { print "$1\t$2\t$3\t$4"; }')
	if [ -n "$LOGIN" ]; then
		PLAYER_NAME=$(printf "$LOGIN" | cut -f1)

		# Add the user to the world.users file.
		execute "printf \"$LOGIN\n\" >> \"$WORLDS_LOCATION/$1.users\"" $USER_NAME

		# Announce the user logging in via lib-notify.
		if [ $USE_LIBNOTIFY ]; then
			libNotify "Minecraft - $1" "$PLAYER_NAME has logged into world."
		fi

		# Whisper the MOTD to the user logging in.
		tellMOTD $1 $PLAYER_NAME
	fi
}

# Check for users logging out of a world.  if a user logs out, perform the
# logout functions.
#
# @param 1 The world server of interest.
# @param 2 The message to check for users logging out.
checkForLogout() {
	local LOGOUT BAN PLAYER_NAME
	LOGOUT=$(echo "$2" | $PERL -ne 'if ($_ =~ /(\w+) lost connection\: (.+)/) { print "$1\t$2"; }')
	BAN=$(echo "$2" | $PERL -ne 'if ($_ =~ /Disconnecting (\w+)\s*\[\/([0-9\.\:]+)\]\: You are banned/) { print "$1\t$2"; }')
	if [ -n "$LOGOUT" ]; then
		PLAYER_NAME=$(printf "$LOGOUT" | cut -f1)

		# Remove the user from the world.users file.
		execute "$PERL -i -ne 'print unless /^$PLAYER_NAME\t[0-9\.]+\t\d+\d+/;' $WORLDS_LOCATION/$1.users" $USER_NAME
		
		# Announce the user logging out via lib-notify.
		if [ $USE_LIBNOTIFY ]; then
			libNotify "Minecraft - $1" "$PLAYER_NAME has logged out of world."
		fi
	elif [ -n "$BAN" ]; then
		PLAYER_NAME=$(printf "$BAN" | cut -f1)
		
		# Remove the user from the world.users file.
		execute "$PERL -i -ne 'print unless /^$PLAYER_NAME\t[0-9\.]+\t\d+\d+/;' $WORLDS_LOCATION/$1.users" $USER_NAME
		
		# Announce the user ban via lib-notify.
		if [ $USE_LIBNOTIFY ]; then
			libNotify "Minecraft - $1" "$PLAYER_NAME has been banned from the world."
		fi
	fi
}

# Parse through the log file for the given world.  Uses checkFor methods to
# find events such as users logging in or out.
#
# @param 1 The world server generating the log to parse.
parseLog() {
	local LINE DATE TIME TYPE MESSAGE
	while read LINE; do
		LINE=$(echo "$LINE" | $PERL -ne 'if ($_ =~ /(.+) (.+) \[(\w+)\] (.+)/) { print "$1\t$2\t$3\t$4"; }')
		DATE=$(echo "$LINE" | cut -f1)
		TIME=$(echo "$LINE" | cut -f2)
		TYPE=$(echo "$LINE" | cut -f3)
		MESSAGE=$(echo "$LINE" | cut -f4)
		case "$TYPE" in
			INFO)
				checkForLogin $1 "$MESSAGE"
				checkForLogout $1 "$MESSAGE"
			;;
			SEVERE)
				if [ $AUTO_RESTART_ON_ERROR -eq 1 ]; then
					sendCommand $1 "say The server is experiencing issues, restarting in 5 seconds..."
					sleep 5
					stop $1
					sleep 5
					start $1
				fi
			;;
			WARNING)
			;;
			*)
			;;
		esac
	done
}

# Rotates the world server log file.
#
# @param 1 The world server generating the log to rotate.
rotateLog() {
	local WORLD_DIR LOG_LIST LOG_LINES LOG_NUMBER
	WORLD_DIR="$WORLDS_LOCATION/$1"

	# Make sure that the server.log file exists.
	execute "touch $WORLD_DIR/server.log" $USER_NAME

	# Scan the log for entires and skip rotate is none are found.
	LOG_LINES="$(cat "$WORLD_DIR/server.log" | wc -l )"
	if [ $LOG_LINES -le 1 ]; then
		printf "\nNo new log entries to rotate. No changes made.\n"
		return 0
	fi

	# Server logfiles in chronological order.
	LOGLIST=$(ls -r $WORLD_DIR/server.log* | grep -v lck)

	# Look at all the logfiles
	for i in $LOGLIST; do
		LOG_NUMBER=$(ls $i | cut -d "." -f 3)

		 # if we're working with server.log, append .1 then compress it.
		if [ -z $LOG_NUMBER ]; then
			LOG_NUMBER="1"
			execute "cp $WORLD_DIR/server.log $WORLD_DIR/server.log.$LOG_NUMBER" $USER_NAME
			execute "gzip $WORLD_DIR/server.log.$LOG_NUMBER" $USER_NAME

		# Otherwise, check if the file number is under $LOG_COUNT.
		elif [ $LOG_NUMBER -ge $LOG_COUNT ]; then
			# if so, delete it.
			execute "rm -f $i" $USER_NAME
		else
			# Otherwise, add one to the number.
			LOG_NUMBER=$(($LOG_NUMBER+1))
			execute "mv -f $i $WORLD_DIR/server.log.$LOG_NUMBER.gz" $USER_NAME
		fi
	done

	# Blank the existing logfile to renew it.
	execute "cp /dev/null $WORLD_DIR/server.log" $USER_NAME
}

# Watch the world server log file.
#
# @param 1 The world server generating the log to watch.
watchLog() {
	local PID WORLD_DIR
	WORLD_DIR="$WORLDS_LOCATION/$1"

	# Make sure that the server.log file exists.
	if [ -e "$WORLD_DIR/server.log" ]; then
		# Watch the log.
		PID=$(echo $(getProcessIDs $1) | cut -d ' ' -f2)
		tail -n0 -f --pid=$PID $WORLD_DIR/server.log
	fi
}

# Synchronizes the data stored in the mirror images.
#
# @param 1 The world server to sync.
syncMirrorImage() {
	# Sync the world server.
	execute "cp -Ru $MIRROR_PATH/$1/* $WORLDS_LOCATION/$1/$1" $USER_NAME
	if [ $? -ne 0 ]; then
		printf "Error synchronizing mirror images for world $1.\n"
		exit 1
	fi
}

# Create a blank <world>.conf file if one is missing.
#
# @param1: The name of the world whose CONFIG file needs to be created.
createWorldCONFIG() {
	printf "\nWorld CONFIG file \"$1.conf\" was not found. Creating a new one...\n"

	execute "printf \"# MSCS World Configuration\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# ------------------------\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# Server JAR file to use for this instance of a Minecraft server. if this differs from the name\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# in the URL below, the file will be renamed to this after downloading.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export SERVER_JAR=\"server.jar\"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# The full URL to download the above JAR file. Include the file's name.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export SERVER_URL=\"http://url/to/server.jar\"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# Initial and maximum RAM to allocate to the server instance. NOTE: Values over 2G -require- using\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# a 64-bit OS and the 64-bit Java JRE. Make sure your computer has enough physical memory (NOT swap\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# space!) to support your desired allocation amount - if there's not enough RAM, Java will complain\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# and your server may not run correctly - or at all!\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export INITIAL_MEMORY=\"1024M\"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export MAXIMUM_MEMORY=\"2048M\"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# Post-jar arguments, if any. This usually doesn't need to be edited.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export SERVER_ARGS=\"nogui\"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# Java JRE configuration parameters follow. Uncomment/edit as needed.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# This is a bare-bones minimal configuration set for running a Minecraft server without any special\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# Configuration settings aside from an increased MaxPermSize so you won't encounter out-of-memory\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# errors quite so quickly. Use this line (and comment out the other SERVER_CONFIG lines) to make sure\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# a newly created server is running before optimizing Java.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export SERVER_CONFIG=\"-XX:MaxPermSize=128m\"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# The actual server command to use to invoke the Java JRE to run the server jar. Generally speaking,\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# this should not be edited directly but should instead be manipulated by editing the lines above.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export SERVER_COMMAND=\"$JAVA -server -Xms$INITIAL_MEMORY -Xmx$MAXIMUM_MEMORY $SERVER_CONFIG -cp $SERVER_LOCATION/$SERVER_JAR -jar $SERVER_LOCATION/$SERVER_JAR $SERVER_ARGS\"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# Enable or disable mirroring of the world files for this server.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"export ENABLE_MIRROR=0\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# Last thing: remove the following line so the script won't abort. This is a sanity check to see\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"# if you read and edited everything.\n\" >> $LOCATION/$1.conf" $USER_NAME
	execute "printf \"exit 1\n\" >> $LOCATION/$1.conf" $USER_NAME


	printf "A new world CONFIG file has been created as \"$LOCATION/$1.conf\". Please edit this file as needed, and retry.\n"
}

# Start the world server and the log processor.  Generate the appropriate
# environment for the server if it doesn't already exist.
#
# @param 1 The world server to start.
start() {
	local PID WORLD_DIR ERROR_CODE
	# Check for a world config file. if there isn't one for this world, create a basic one
	# and stop.
	printf " Checking config..." 
    if [ ! -e "$LOCATION/$1.conf" ]; then
		createWorldCONFIG $1
		exit 1
    fi

	# Load the .conf file for this world. This will automagically insert the appropriate
	# variables for the particular server instance that will power the world.
	. "$LOCATION/$1.conf"

	# Make sure that the world's directory exists.
	WORLD_DIR="$WORLDS_LOCATION/$1"
	execute "mkdir -p $WORLD_DIR" $USER_NAME

	# Make sure that the server.properties file holds the correct values.
	setPropertiesValue $WORLDS_LOCATION/$1/server.properties "level-name"  "$1"
	setPropertiesValue $WORLDS_LOCATION/$1/server.properties "server-port" "$(getPort $1)"
	setPropertiesValue $WORLDS_LOCATION/$1/server.properties "server-ip"   "$(getIP $1)"
	setPropertiesValue $WORLDS_LOCATION/$1/server.properties "motd"        "$(getMOTD)"

	# Make a mirror image of the world directory if requested.
	if [ $ENABLE_MIRROR -eq 1 ] && [ -d $MIRROR_PATH ]; then
		printf " Copying world data to the mirror location - this may take a few minutes..."
		execute "mkdir -p $MIRROR_PATH/$1" $USER_NAME
		#execute "cp -R $WORLDS_LOCATION/$1/* $MIRROR_PATH/$1" $USER_NAME
		#WORLD_DIR="$MIRROR_PATH/$1"
		#
		# The original script copied the whole server to RAM. While this did make for a faster
		# server, it also meant that things that didn't need to be copied over, were, which eats
		# MUCH more memory than only copying the world files themselves over. This modification
		# involves moving only the world files over, renaming the original world-file directory,
		# and creating a symlink to point the server to the relocated world files in RAM.
		#
		# Start by checking for a clean dismount from the previous server run. if we have a 
		# <world>-original directory within <world> we probably didn't stop cleanly.
		if [ -d "WORLDS_LOCATION/$1/$1-original" ]; then

			# Remove the symlink to the world-file mirror image.
			execute "rm -r $WORLDS_LOCATION/$1/$1" $USER_NAME

			# Move the world files back to their original path name.
			execute "mv $WORLDS_LOCATION/$1/$1-original $WORLDS_LOCATION/$1/$1" $USER_NAME
		fi

		# Copy the world files over to the mirror.
		execute "cp -R $WORLDS_LOCATION/$1/$1/* $MIRROR_PATH/$1" $USER_NAME

		# Rename the original world file directory.
		execute "mv $WORLDS_LOCATION/$1/$1 $WORLDS_LOCATION/$1/$1-original" $USER_NAME

		# Create a symlink from the world file directory's original name to the mirrored files.
		execute "ln -s $MIRROR_PATH/$1 $WORLDS_LOCATION/$1/$1" $USER_NAME

	elif [ $ENABLE_MIRROR -eq 1 ]; then
		printf " Error copying the world data to the mirror location, mirror path $MIRROR_PATH/$1 not found."
		exit 1
	fi                   

	# Check to see if the server jar exists, and if not, download it.
	if [ ! -e "$SERVER_LOCATION/$SERVER_JAR" ]; then
		printf " Server software not found - trying to download it..."
		updateServerSoftware $1
	fi

	# Change to the world's directory.
	cd $WORLD_DIR

	printf " Trying to start..."

	# Make sure that the server.log file exists.
	execute "touch server.log" $USER_NAME

	# Erase the world's users file before starting up the world, in
	# case it is not already empty for some reason.
	execute "printf \"\" > \"$WORLDS_LOCATION/$1.users\"" $USER_NAME

	# Start the server.
	execute "$SCREEN -dmS minecraft-$1 $SERVER_COMMAND" $USER_NAME

        ERROR_CODE=$?
	if [ $ERROR_CODE -ne 0 ]; then
		printf " Error starting the server: Java returned error code $ERROR_CODE.\n"
		exit $ERROR_CODE
	fi

	# Grab the Process ID of the screen.
	PID=$(echo $(getProcessIDs $1) | cut -d ' ' -f1)
	if [ ! -n "$PID" ]; then
		printf " Error starting the server: SCREEN failed to create a screen for the server.\n"
		exit 1
	fi

	# Grab the Process ID of the server's Java instance.
	PID=$(echo $(getProcessIDs $1) | cut -d ' ' -f2)
	if [ ! -n "$PID" ]; then
		printf " Error starting the server: couldn't retrieve the server's process ID.\n"
		exit 1
	fi

	# Start the log processor.
	tail -n0 -f --pid=$PID $WORLD_DIR/server.log | parseLog $1 &

	# Create a lock file on RedHat and derivatives.
	if [ -d "/var/lock/subsys" ]; then
		touch /var/lock/subsys/minecraft_server
	fi
}

# Stop the world server.
#
# @param 1 The world server to stop.
stop() {
	local WORLD NUM	
	# Check for a world config file. if there isn't one for this world, create a basic one
	# and stop.
	printf " Checking config..." 
    if [ ! -e "$LOCATION/$1.conf" ]; then
		createWorldCONFIG $1
		exit 1
    fi

	# Load the .conf file for this world. This will automagically insert the appropriate
	# variables for the particular server instance that will power the world.
	. "$LOCATION/$1.conf"

	# Send a "stop" command to the server. Duh.
	sendCommand $1 "stop"

	# Erase the world's users file since we won't be able to catch
	# anyone logging off.
	execute "printf \"\" > \"$WORLDS_LOCATION/$1.users\"" $USER_NAME

	# Synchronize the mirror image of the world prior to closing, if required.
	if [ $ENABLE_MIRROR -eq 1 ] && [ -d $MIRROR_PATH ]; then
		syncMirrorImage $1

		# Remove the symlink to the world-file mirror image.
		execute "rm -r $WORLDS_LOCATION/$1/$1" $USER_NAME

		# Move the world files back to their original path name.
		execute "mv $WORLDS_LOCATION/$1/$1-original $WORLDS_LOCATION/$1/$1" $USER_NAME
	fi

	# Remove the lock file on Redhat and derivatives if all world servers are stopped.
	if [ -e "/var/lock/subsys/minecraft_server" ]; then
		NUM=0
		for WORLD in $ALL_WORLDS; do
			if [ "$1" != "$WORLD" ] && [ $(serverRunning $WORLD) -eq 1 ]; then
				NUM=$(($NUM + 1))
			fi
		done
		if [ $NUM -eq 0 ]; then
			rm -f /var/lock/subsys/minecraft_server
		fi
	fi
}

# Forcibly stop the world server.
#
# @param 1 The world server to forcibly stop.
forceStop() {
	# Check for a world config file. if there isn't one for this world, create a basic one
	# and stop.
	printf " Checking config..." 
    if [ ! -e "$LOCATION/$1.conf" ]; then
		createWorldCONFIG $1
		exit 1
    fi

	# Load the .conf file for this world. This will automagically insert the appropriate
	# variables for the particular server instance that will power the world.
	. "$LOCATION/$1.conf"

	# Synchronize the mirror image of the world prior to closing, if required.
	if [ $ENABLE_MIRROR -eq 1 ] && [ -d $MIRROR_PATH ]; then

		# Remove the symlink to the world-file mirror image.
		execute "rm -r $WORLDS_LOCATION/$1/$1" $USER_NAME

		# Move the world files back to their original path name.
		execute "mv $WORLDS_LOCATION/$1/$1-original $WORLDS_LOCATION/$1/$1" $USER_NAME
	fi

	local PIDS
	PIDS=$(getProcessIDs $1)

	# Try to stop the server cleanly first. We'll give it 60 seconds to do so before
	# kiling it.
	stop $1
	sleep 60

	# Kill the process ids of the world server.
	kill -9 $PIDS > /dev/null 2>&1

	# Remove the lock file on Redhat and derivatives if it is still around.
	rm -f /var/lock/subsys/minecraft_server
}

# Backup the world server's world files.
#
# @param 1 The world server to backup.
worldBackup() {
	# Check for a world config file. if there isn't one for this world, create a basic one
	# and stop.
	printf " Checking config..." 
    if [ ! -e "$LOCATION/$1.conf" ]; then
		createWorldCONFIG $1
		exit 1
    fi

	# Load the .conf file for this world. This will automagically insert the appropriate
	# variables for the particular server instance that will power the world.
	. "$LOCATION/$1.conf"

	# Sanity check - is at least one backup method enabled?
	if [ $ENABLE_TARBALLING -ne 1 ] && [ $ENABLE_RDIFF -ne 1 ]; then
 		printf "Neither tarballing nor rdiff-backup are enabled. Please enable one or both and retry."
		exit 1
	fi

	# Attempt to set a lock directory, and create a trap to unset the lock directory on complete.
	LOCKDIR="$BACKUP_LOCATION/$1/backup.lock"
	execute "mkdir \"$LOCKDIR\"" $USER_NAME
	trap 'rm -rf "$LOCKDIR"' 0

    # Save and sync the world if mirroring is enabled.
    if [ $ENABLE_MIRROR -eq 1 ]; then
		syncMirrorImage $1
	fi

	# Make sure that the backup location exists.
	execute "mkdir -p $BACKUP_LOCATION/world_$1" $USER_NAME

	# Tarball creation - when enabled (ENABLE_TARBALLING=1), a backup archive file will be created
	# that contains the world files. This can be downloaded for offsite storage and recovery.
	if [ $ENABLE_TARBALLING -eq 1 ]; then

		# New backup script: instead of using rdiff-backup to keep an incremental/mirrored copy of the
        # whole server, this new system just tarballs the world files. This allows for off-site backup
        # without having to CONFIGure a target for rdiff-backup - just decompress the tarball over the
        # existing world files to revert them to whatever versions existed when the tarball was created.

        # Create a new backup tar.gz of the current world, using the current datetime as part of the filename.
        BACKUP_FILE="worldfiles_$1_$(date +%d%b%Y_%I-%M-%S-%p).tar.gz"
		execute "$TAR -pczvf $BACKUP_LOCATION/world_$1/$BACKUP_FILE $WORLDS_LOCATION/$1/$1 >> /dev/null" $USER_NAME

		# Get the backup tarball's file size, in human-friendly format.
		FILESIZE=$(du -sh $BACKUP_LOCATION/world_$1/$BACKUP_FILE | cut -f1)

		# Tell the players about the backup. This helps reinforce the idea that your server is so elite
		# that it routinely archives the world files for safety.
		sendCommand $1 "say World files archived to file '$BACKUP_FILE'. ($FILESIZE)"

        # Delete backup files older than $BACKUP_DURATION days.
        execute "find $BACKUP_LOCATION/world_$1 -type f -mtime +$BACKUP_DURATION -exec rm {} +" $USER_NAME
	fi

	# RDIFF-BACKUP method - when enabled (ENABLE_RDIFF=1), an incremental-mirror backup is created of
	# the world files via rdiff-backup.
	if [ $ENABLE_RDIFF -eq 1 ]; then
		# Original script follows...
		#
		# Create the backup.
		#execute "$RDIFF_BACKUP -v5 --print-statistics $WORLDS_LOCATION/$1 $BACKUP_LOCATION/$1 >> $BACKUP_LOG" $USER_NAME
		#
		# NOTE: modified to only back up the actual world files, and not the entire server directory as was
		# the script's original setup. The reasons for this: 1: It only takes about half an hour to rebuild
		# a Minecraft server; and 2: if you use a plugin like Dynmap you're going to have 2-10 extra gigabytes
		# of data that doesn't actually need to be backed up but would be anyway under the original setup.
		execute "$RDIFF_BACKUP -v5 --print-statistics $WORLDS_LOCATION/$1/$1 $BACKUP_LOCATION/world_$1 >> $BACKUP_LOG" $USER_NAME
	
		# Cleanup old backups.
		if [ $BACKUP_DURATION -gt 0 ]; then
			execute "$RDIFF_BACKUP --remove-older-than ${BACKUP_DURATION}D --force $BACKUP_LOCATION/world_$1 >> $BACKUP_LOG" $USER_NAME
		fi
	fi

	# Remove the lock.
	execute "rm -rf \"$LOCKDIR\"" $USER_NAME
}

# Backup the world server in its entirety.
#
# @param 1 The world server to backup.
worldFullBackup() {
	# Check for a world config file. if there isn't one for this world, create a basic one
	# and stop.
	printf " Checking config..." 
    if [ ! -e "$LOCATION/$1.conf" ]; then
		createWorldCONFIG $1
		exit 1
    fi

	# Load the .conf file for this world. This will automagically insert the appropriate
	# variables for the particular server instance that will power the world.
	. "$LOCATION/$1.conf"

	# Sanity check - is at least one backup method enabled?
	if [ $ENABLE_TARBALLING -ne 1 ] && [ $ENABLE_RDIFF -ne 1 ]; then
 		printf "Neither tarballing nor rdiff-backup are enabled. Please enable one or both and retry."
		exit 1
	fi

	# Attempt to set a lock directory, and create a trap to unset the lock directory on complete.
	LOCKDIR="$BACKUP_LOCATION/$1/backup.lock"
	execute "mkdir \"$LOCKDIR\"" $USER_NAME
	trap 'rm -rf "$LOCKDIR"' 0

    # Save and sync the world if mirroring is enabled.
    if [ $ENABLE_MIRROR -eq 1 ]; then
		syncMirrorImage $1
	fi

	# Make sure that the backup location exists.
	execute "mkdir -p $BACKUP_LOCATION/server_$1" $USER_NAME

	# Tarball creation - when enabled (ENABLE_TARBALLING=1), a backup archive file will be created
	# that contains the world files. This can be downloaded for offsite storage and recovery.
	if [ $ENABLE_TARBALLING -eq 1 ]; then

        # Create a new backup tar.gz of the current world, using the current datetime as part of the filename.
        BACKUP_FILE="fullserver_$1_$(date +%d%b%Y_%I-%M-%S-%p).tar.gz"
        execute "$TAR -pczvf $BACKUP_LOCATION/server_$1/$BACKUP_FILE $WORLDS_LOCATION/$1/$1 >> /dev/null" $USER_NAME

		# Get the backup tarball's file size, in human-friendly format.
		FILESIZE=$(du -sh $BACKUP_LOCATION/server_$1/$BACKUP_FILE | cut -f1)

		# Tell the players about the backup. This helps reinforce the idea that your server is so elite
		# that it routinely archives the world files for safety.
		sendCommand $1 "say Server's full file set archived to file '$BACKUP_FILE'. ($FILESIZE)"

		# Delete backup files older than $BACKUP_DURATION days.
		execute "find $BACKUP_LOCATION/server_$1 -type f -mtime +$BACKUP_DURATION -exec rm {} +" $USER_NAME
	fi
	
	# RDIFF-BACKUP method - when enabled (ENABLE_RDIFF=1), an incremental-mirror backup is created of
	# the world files via rdiff-backup.
	if [ $ENABLE_RDIFF -eq 1 ]; then
		execute "$RDIFF_BACKUP -v5 --print-statistics $WORLDS_LOCATION/$1 $BACKUP_LOCATION/server_$1 >> $BACKUP_LOG" $USER_NAME

		# Cleanup old backups.
		if [ $BACKUP_DURATION -gt 0 ]; then
			execute "$RDIFF_BACKUP --remove-older-than ${BACKUP_DURATION}D --force $BACKUP_LOCATION/server_$1 >> $BACKUP_LOG" $USER_NAME
		fi
	fi

	# Remove the lock.
	execute "rm -rf \"$LOCKDIR\"" $USER_NAME
}

# update the Minecraft client software.
updateClientSoftware() {                                
	# Make sure the client software directory exists.
	execute "mkdir -p $CLIENT_LOCATION" $USER_NAME

	# Backup the old client jar.
	if [ -e "$CLIENT_LOCATION/$CLIENT_JAR" ]; then
		execute "mv -f \"$CLIENT_LOCATION/$CLIENT_JAR\" \"$CLIENT_LOCATION/$CLIENT_JAR.old\"" $USER_NAME
	fi

	# Download the new Minecraft client software
	execute "$WGET -qO \"$CLIENT_LOCATION/$CLIENT_JAR\" \"$CLIENT_URL\"" $USER_NAME
	
	# Check for error and restore backup if found.
	if [ $? -ne 0 ]; then
		printf "\nError updating the Minecraft client software.\n"
		if [ -e "$CLIENT_LOCATION/$CLIENT_JAR.old" ]; then
			execute "mv -f \"$CLIENT_LOCATION/$CLIENT_JAR.old\" \"$CLIENT_LOCATION/$CLIENT_JAR\"" $USER_NAME
		fi
	fi
}

# Update the Minecraft server software.
#
# @param 1 The world whose server jar to update.
updateServerSoftware() {
	# Check for a world config file. if there isn't one for this world, create a basic one
	# and stop.
	if [ ! -e "$LOCATION/$1.conf" ]; then
  		createWorldCONFIG $1
		exit 1
	fi

	# Load the .conf file for this world.
	. $LOCATION/$1.conf

	# Make sure the server jar storage directory exists.
	execute "mkdir -p $SERVER_LOCATION" $USER_NAME

	# Backup the old jar file.
	if [ -e "$SERVER_LOCATION/$SERVER_JAR" ]; then
		execute "mv -f \"$SERVER_LOCATION/$SERVER_JAR\" \"$SERVER_LOCATION/$SERVER_JAR.old\"" $USER_NAME
	fi

	# Download the new minecraft server software.
	execute "$WGET -qO \"$SERVER_LOCATION/$SERVER_JAR\" \"$SERVER_URL\"" $USER_NAME

	# Check for error and restore backup if found.
	if [ $? -ne 0 ]; then
		printf "\nError updating the Minecraft server software.\n"
		if [ -e "$SERVER_LOCATION/$SERVER_JAR.old" ]; then
			execute "mv -f $SERVER_LOCATION/$SERVER_JAR.old $SERVER_LOCATION/$SERVER_JAR" $USER_NAME
		fi
		exit 1
	fi
}

# NOTE: This function is obsolete. Call updateServerSoftware or updateClientSoftware directly.
# --------------------------------------------------------------------------------------------
# Update a software package.  Uses the other update functions to actually
# perform the update.
#
# @param 1 The package to update.
#update() {
#	case "$1" in
#		server)
#			updateServerSoftware
#		;;
#		client)
#			updateClientSoftware
#		;;
#		*)
#			printf "Unknown software package: $1\n"
#			exit 1
#		;;
#	esac
#}

# Run Minecraft Overviewer mapping software on the world.  Generates an
# index.html file using the Google Maps API.
#
# @param 1 The world server to map with Overviewer.
overviewer() {
	# Make sure the maps directory exists.
	execute "mkdir -p $MAPS_LOCATION/$1" $USER_NAME

	# Make sure the Minecraft client is available.
	if [ ! -e "$CLIENT_LOCATION/$CLIENT_JAR" ]; then
		updateClientSoftware
	fi

	# Make sure that the world files are actually there before mapping.

	if [ -e "$WORLDS_LOCATION/$1/server.properties" ]; then
		# Check for Overviewer settings file.
		if [ -e "$WORLDS_LOCATION/$1/overviewer-settings.py" ]; then
			# Generate map and POI with custom settings.
			execute "$OVERVIEWER_BIN --CONFIG=$WORLDS_LOCATION/$1/overviewer-settings.py" $USER_NAME
			execute "$OVERVIEWER_BIN --CONFIG=$WORLDS_LOCATION/$1/overviewer-settings.py --genpoi" $USER_NAME
		else
			# Generate map with default settings.
			execute "$OVERVIEWER_BIN --rendermodes=normal,lighting,cave --processes 1 $WORLDS_LOCATION/$1/$1 $MAPS_LOCATION/$1" $USER_NAME > /dev/null 2>&1
		fi
	fi
}


# Ready? Begin!


# Make sure that Java, Perl, Python, Rsync, GNU Screen, and GNU Wget are installed.
if [ ! -e "$JAVA" ]; then
	printf "ERROR: Java not found!\n"
	printf "Try installing this with:\n"
	printf "sudo apt-get install openjdk-6-jdk"
	exit 1
fi
if [ ! -e "$PERL" ]; then
	printf "ERROR: Perl not found!\n"
	printf "Try installing this with:\n"
	printf "sudo apt-get install perl\n"
	exit 1
fi
if [ ! -e "$PYTHON" ]; then
	printf "ERROR: Python not found!\n"
	printf "Try installing this with:\n"
	printf "sudo apt-get install python\n"
	exit 1
fi
if [ ! -e "$RSYNC" ] && [ $ENABLE_MIRROR -eq 1 ]; then
	printf "ERROR: Rsync not found!\n"
	printf "Try installing this with:\n"
	printf "sudo apt-get install rsync\n"
	exit 1
fi
if [ ! -e "$SCREEN" ]; then
	printf "ERROR: GNU Screen not found!\n"
	printf "Try installing this with:\n"
	printf "sudo apt-get install screen\n"
	exit 1
fi
if [ ! -e "$WGET" ]; then
	printf "ERROR: GNU Wget not found!\n"
	printf "Try installing this with:\n"
	printf "sudo apt-get install wget\n"
	exit 1
fi
if [ ! -e "$RDIFF_BACKUP" ]; then
	printf "ERROR: rdiff-backup not found!\n"
	printf "Try installing this with:\n"
	printf "sudo apt-get install rdiff-backup\n"
	exit 1
fi

# Make sure that the minecraft user exists.
if [ ! -n "$(grep $USER_NAME /etc/passwd)" ]; then
	printf "ERROR: This script requires that a user account named $USER_NAME exist on this system.\n"
	printf "Either modify the USER_NAME variable in this script, or try adding this user:\n"
	printf "sudo adduser $USER_NAME\n"
	exit 1
fi

# Warn if the script is running with the wrong user.
if [ $(id -u) -ne 0 ] && [ "$(whoami)" != "$USER_NAME" ]; then
	printf "WARNING: This script appears to have been started by the wrong user.\n"
	printf "Expected to find the user: $USER_NAME.  You can try to log on to this user:\n"
	printf "su $USER_NAME\n"
	exit 1
fi

# Generate a default worlds.conf file if it does not already exist.
if [ ! -e "$WORLDS_CONF" ]; then
	execute "printf \"# Minecraft world configuration file\n\" > $WORLDS_CONF" $USER_NAME
	execute "printf \"# <world>\t<port>\t<ip>\n\" >> $WORLDS_CONF" $USER_NAME
	execute "printf \"$DEFAULT_WORLD\t$DEFAULT_PORT\t$DEFAULT_IP\n\" >> $WORLDS_CONF" $USER_NAME
fi

# Update old worlds.conf files.
if [ -e "$WORLDS_CONF" ] && [ "$(grep '<eport>' $WORLDS_CONF)" != ""  ]; then
	execute "cp $WORLDS_CONF $WORLDS_CONF.old" $USER_NAME
	execute "$PERL -i -ne 'if (\$_ =~ /#\s*<world>\s+<eport>\s+<iport>\s+<ip>/) { print \"# <world>\t<port>\t<ip>\n\"; } else { print; }' $WORLDS_CONF" $USER_NAME
	execute "$PERL -i -ne 'if (\$_ =~ /(\w+)\s+(\d+)\s+\d+\s*([\d\.]*)/) { printf \"%s\t%d\t%s\n\",\$1,\$2,\$3; } else { print; }' $WORLDS_CONF" $USER_NAME
fi

# Grab the list of worlds.
ALL_WORLDS=$(getWorlds)

# Respond to the command line arguments.
case "$1" in
	start)
		# figure out which worlds to start.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Start each world requested, if not already running.
		printf "Starting Minecraft Server(s)...\n"
		printf "===============================\n"
		for WORLD in $WORLDS; do
			if [ $(serverRunning $WORLD) -eq 0 ]; then
				printf "$WORLD:"
				start $WORLD
				printf " Done.\n"
			else
				printf "$WORLD: Skipped - already running.\n"
			fi
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	force-start)
		# figure out which worlds to start.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Start each world requested, if not already running.
		printf "Starting Minecraft Server(s)...\n"
		printf "===============================\n"
		for WORLD in $WORLDS; do
			#if [ $(serverRunning $WORLD) -eq 0 ]; then
				printf "$WORLD:"
				start $WORLD
				printf " Done.\n"
			#else
			#	printf "$WORLD: Skipped - already running.\n"
			#fi
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	powercycle)
		# figure out which worlds to start.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Start each world requested, if not already running.
		printf "Power-cycling Minecraft Server(s)...\n"
		printf "====================================\n"
		for WORLD in $WORLDS; do
			# Stop the world (cleanly if possible) if the server is running.
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				printf "$WORLD: Stopping"
				sendCommand $WORLD "say Power-cycling and backing up server - this will take a few minutes."
				sendCommand $WORLD "say The server is restarting in 60 seconds..."
					printf " in 60s..."
				sleep 30
				sendCommand $WORLD "say The server is restarting in 30 seconds..."
				printf " 30s..."
				sleep 15
				sendCommand $WORLD "say The server is restarting in 15 seconds..."
				printf " 15s..."
				sleep 5
				sendCommand $WORLD "say The server is restarting in 10 seconds..."
				printf " 10s..."
				sleep 5
				sendCommand $WORLD "say The server is restarting in 5 seconds..."
				sendCommand $WORLD "save-all"
				sendCommand $WORLD "save-off"
				printf " 5s..."
				sleep 5
				printf " stopping..."
				if [ "$1" = "force-stop" ]; then
					forceStop $WORLD
				else
					stop $WORLD
				fi
				sleep 5
			else
				printf " Server $WORLD not running."
			fi

			# Pull a full backup on the world's actual world files.
			printf " Backing up $WORLD... "
			worldBackup $WORLD
	
			# Restart the world.
			printf " Restarting $WORLD... "
			if [ $(serverRunning $WORLD) -eq 0 ]; then
				start $WORLD
			fi

			# And on to the next world...
			printf "\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;
	
	scheduled-restart)
		# Check for the world command line argument.
		if [ -n "$2" ] && [ $(listContains $2 "$ALL_WORLDS") -eq 1 ]; then
			printf "Performing Scheduled Restart on Minecraft Server...\n"
			printf "===================================================\n"
			printf "$2:"
			if [ $(serverRunning $2) -eq 0 ]; then
				printf " Stopping"
				sendCommand $2 "say A scheduled server restart is coming up. Please get somewhere safe."
				sendCommand $2 "say The server is restarting in 10 minutes..."
				printf " in 10m..."
				sleep 300
				sendCommand $2 "say A scheduled server restart is coming up. Please get somewhere safe."
				sendCommand $2 "say The server is restarting in 5 minutes..."
				printf " in 5m..."
				sleep 240
				sendCommand $2 "say A scheduled server restart is coming up. Please get somewhere safe."
				sendCommand $2 "say The server is restarting in 60 seconds..."
				printf " in 60s..."
				sleep 30
				sendCommand $2 "say The server is restarting in 30 seconds..."
				printf " 30s..."
				sleep 15
				sendCommand $2 "say The server is restarting in 15 seconds..."
				printf " 15s..."
				sleep 5
				sendCommand $2 "say The server is restarting in 10 seconds..."
				printf " 10s..."
				sleep 5
				sendCommand $2 "say The server is restarting in 5 seconds..."
				sendCommand $2 "save-all"
				sendCommand $2 "save-off"
				printf " 5s..."
				sleep 5
				printf " stopping..."
				stop $2
			fi
			printf " restarting..."
			start $2
			printf " Done.\n"
		else
			if [ -n "$2" ]; then
				printf "Minecraft world $2 not found!\n"
			else
				printf "Minecraft world not provided!\n"
			fi
			printf "  Usage:  $0 $1 <world>\n"
			exit 1
		fi
	;;

	watchstart)
		# Check for the world command line argument.
		if [ -n "$2" ] && [ $(listContains $2 "$ALL_WORLDS") -eq 1 ]; then
			if [ $(serverRunning $2) -eq 0 ]; then
				printf "Starting Minecraft server $2, then jumping to its log screen..."
				start $2
			fi
			displayScreen $2
		else
			if [ -n "$2" ]; then
				printf "Minecraft world $2 not found!\n"
			else
				printf "Minecraft world not provided!\n"
			fi
			printf "  Usage:  $0 $1 <world>\n"
			exit 1
		fi
	;;

	stop|force-stop)
		# figure out which worlds to stop.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Stop each world requested, if running.
		printf "Stopping Minecraft Server(s)...\n"
		printf "===============================\n"
		for WORLD in $WORLDS; do
			# Try to stop the world cleanly.
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				printf "$WORLD: Stopping"
				sendCommand $WORLD "say An Administrator has triggered a server shutdown. Please get somewhere safe."
				sendCommand $WORLD "say The server is going down in 60 seconds..."
				printf " in 60s..."
				sleep 30
				sendCommand $WORLD "say The server is going down in 30 seconds..."
				printf " 30s..."
				sleep 15
				sendCommand $WORLD "say The server is going down in 15 seconds..."
				printf " 15s..."
				sleep 5
				sendCommand $WORLD "say The server is going down in 10 seconds..."
				printf " 10s..."
				sleep 5
				sendCommand $WORLD "say The server is going down in 5 seconds..."
				sendCommand $WORLD "save-all"
				sendCommand $WORLD "save-off"
				printf " 5s..."
				sleep 5
				printf " stopping..."
				if [ "$1" = "force-stop" ]; then
					forceStop $WORLD
				else
					stop $WORLD
				fi
				sleep 5
			fi
			printf "\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	restart|reload|force-restart|force-reload)
		# figure out which worlds to restart.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Restart each world requested, start those not already running.
		printf "Restarting Minecraft Server(s)...\n"
		printf "=================================\n"
		for WORLD in $WORLDS; do
			printf "$WORLD: Stopping"
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				sendCommand $WORLD "say An Administrator has triggered a server restart. Please get somewhere safe."
				sendCommand $WORLD "say The server is restarting in 60 seconds..."
				printf " in 60s..."
				sleep 30
				sendCommand $WORLD "say The server is restarting in 30 seconds..."
				printf " 30s..."
				sleep 15
				sendCommand $WORLD "say The server is restarting in 15 seconds..."
				printf " 15s..."
				sleep 5
				sendCommand $WORLD "say The server is restarting in 10 seconds..."
				printf " 10s..."
				sleep 5
				sendCommand $WORLD "say The server is restarting in 5 seconds..."
				sendCommand $WORLD "save-all"
				sendCommand $WORLD "save-off"
				printf " 5s..."
				sleep 5
				printf " stopping..."
				if [ "$(echo \"$1\" | cut -d '-' -f1)" = "force" ]; then
					forceStop $WORLD
				else
					stop $WORLD
				fi
				sleep 5
			fi
			printf " restarting..."
			start $WORLD
			printf " Done.\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	status|show)
		# figure out which worlds to show the status for.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Show the status of each world requested.
		printf "Minecraft Server Status\n"
		printf "=======================\n"
		for WORLD in $WORLDS; do
			printf " $WORLD: "
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				SERVER_PIDS=$(getProcessIDs $WORLD)
				PID_SCREEN=$(echo $SERVER_PIDS | cut -d ' ' -f1)
				PID_JAVA=$(echo $SERVER_PIDS | cut -d ' ' -f2)
				printf "running (%d users online), with PIDs $PID_JAVA (Java) and $PID_SCREEN (Screen).\n" $(cat $WORLDS_LOCATION/$WORLD.users | wc -l)
			else
				printf "not running.\n"
			fi
		done
	;;

	sync|synchronize)
		# figure out which worlds to synchronize.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Synchronize the images for each world.
		printf "Synchronizing Minecraft Server(s)...\n"
		printf "====================================\n"
		for WORLD in $WORLDS; do
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				printf "Synching $WORLD..."
				if [ -e "$LOCATION/$1.conf" ]; then
					. "$LOCATION/$1.conf"
					
					sendCommand $WORLD "save-off"
					sendCommand $WORLD "save-all"
					sleep 5
					syncMirrorImage $WORLD
					sendCommand $WORLD "save-on"
				else
					printf " Missing config file $LOCATION/$1.conf - skipping...\n"				
				fi
			fi
			printf " Done.\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	send)
		# Check for the world command line argument.
		if [ -n "$2" ] && [ $(listContains $2 "$ALL_WORLDS") -eq 1 ] && [ -n "$3" ]; then
			WORLD=$2
			shift 2
			printf "Sending command to world $WORLD: $*\n"
			sendCommand $WORLD "$*"
		else
			printf "Usage:  $0 $1 <world> <command>\n"
			printf "   ie:  $0 $1 world say Hello World!\n"
			exit 1
		fi
	;;

	screen)
		# Check for the world command line argument.
		if [ -n "$2" ] && [ $(listContains $2 "$ALL_WORLDS") -eq 1 ]; then
			printf "About to load the screen for world $1.\n"
			printf "To exit the screen, hit Ctrl+A then type the letter d.\n"
			sleep 5
			displayScreen $2
		else
			if [ -n "$2" ]; then
				printf "Minecraft world $2 not found!\n"
			else
				printf "Minecraft world not provided!\n"
			fi
			printf "  Usage:  $0 $1 <world>\n"
			exit 1
		fi
	;;

	watch)
		printf "Monitoring Minecraft Server(s)...\n"PIDS=$(getProcessIDs $1)
		printf "=================================\n"

		# Check for the world command line argument.
		if [ -n "$2" ] && [ $(listContains $2 "$ALL_WORLDS") -eq 1 ]; then
			watchLog $2
		else
			if [ -n "$2" ]; then
				printf "Minecraft world $2 not found!\n"
			else
				printf "Minecraft world not provided!\n"
			fi
			printf "  Usage:  $0 $1 <world>\n"
			exit 1
		fi
	;;

	logrotate)
		# figure out which worlds to rotate the log.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Backup each world requested.
		printf "Rotating Minecraft Server Log(s)...\n"
		printf "===================================\n"
		for WORLD in $WORLDS; do
			printf "$WORLD: Working..."
			rotateLog $WORLD
			printf " Done.\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	savetodisk)
		# figure out which worlds to write to disk.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Backup each world requested.
		printf "Flushing Minecraft Server Worlds To Disk...\n"
		printf "===========================================\n"
		for WORLD in $WORLDS; do
			printf "$WORLD"

			# Check to see if the lock directory exists. if so, the world
			# is in the middle of a backup session and we really shouldn't do
			# a save-to-disk.
			LOCKDIR="$BACKUP_LOCATION/$WORLD/backup.lock"
			if [ ! -d "$LOCKDIR" ]; then
				execute "mkdir \"$LOCKDIR\"" $USER_NAME
				trap 'rm -rf "$LOCKDIR"' 0

				printf " is saving world-file changes to disk..."

				sendCommand $WORLD "save-off"
				sendCommand $WORLD "save-all"
				if [ -e "$LOCATION/$1.conf" ]; then
					. "$LOCATION/$1.conf"
					
					if [ $ENABLE_MIRROR -eq 1 ]; then
						# if mirroring is enabled, do a flush to disk.
						printf " and synchronizing..."
                        sleep 5
						syncMirrorImage $WORLD
					fi
				else
					printf " Missing config file $LOCATION/$1.conf - skipping...\n"				
				fi
				sendCommand $WORLD "save-on"
				execute "rm -rf \"$LOCKDIR\"" $USER_NAME
			else
				printf " is backing up - skipped."
			fi
			printf " Done.\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	backup)
		# figure out which worlds to backup.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Backup each world requested.
		printf "Backing Up Minecraft Server World files...\n"
		printf "==========================================\n"
		for WORLD in $WORLDS; do
			printf "$WORLD: Preparing to back up..."
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				sendCommand $WORLD "say Backing up the world... This will take several minutes..."
				sendCommand $WORLD "save-all"
				sendCommand $WORLD "save-off"
				printf " working - this will take a few minutes..."
				worldBackup $WORLD
				sendCommand $WORLD "save-on"
				sendCommand $WORLD "say Backup complete."
			else
				worldBackup $WORLD
			fi
			printf " Done.\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	fullbackup)
		# figure out which worlds to backup.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Backup each world requested.
		printf "Backing Up Minecraft Server World files...\n"
		printf "==========================================\n"
		for WORLD in $WORLDS; do
			printf "$WORLD: Preparing to back up..."
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				sendCommand $WORLD "say Backing up the entire server... This could take half an hour or more..."
				sendCommand $WORLD "save-all"
				sendCommand $WORLD "save-off"
				printf " working - this will take a while..."
				worldFullBackup $WORLD
				sendCommand $WORLD "save-on"
				sendCommand $WORLD "say Backup complete."
			else
				worldBackup $WORLD
			fi
			printf " Done.\n"
		done
		printf "=========\n"
		printf "Finished.\n"
	;;

	update)
		# NOTE: Modified to add support for multiple worlds running multiple server
		# jars with independent configuration setups per world, at the cost of removing 
		# support for updating anything else.
		printf "Updating Minecraft Server JARs...\n"
		printf "=================================\n"

		# Stop all of the world servers and backup the worlds.
		printf "Stopping Minecraft Server(s)..."
		for WORLD in $ALL_WORLDS; do
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				printf "$WORLD: Stopping"
				sendCommand $WORLD "say Server software is being updated."
				sendCommand $WORLD "say A restart will follow. Please get somewhere safe."
		                sendCommand $WORLD "say The server is going down in 60 seconds..."
				printf " in 60s..."
			        sleep 30
		                sendCommand $WORLD "say The server is going down in 30 seconds..."
				printf " 30s..."
		                sleep 15
		                sendCommand $WORLD "say The server is going down in 15 seconds..."
				printf " 15s..."
				sleep 5
				sendCommand $WORLD "say The server is going down in 10 seconds..."
				printf " 10s..."
				sleep 5
				sendCommand $WORLD "say The server is going down in 5 seconds..."
				sendCommand $WORLD "save-all"
				sendCommand $WORLD "save-off"
				printf " 5s..."
				sleep 5
				printf " stopping..."
				stop $WORLD
			fi
			printf " Done.\n"
		done
		printf "finished stopping server(s)\n"

		printf "Backing up Minecraft Server(s)..."
		for WORLD in $ALL_WORLDS; do
			printf "Backing up $WORLD... Expect this to take several minutes... "
			worldBackup $WORLD
			printf " Done.\n"
		done
		printf "finished making backups.\n"

		printf "Updating software package:"
		for WORLD in $ALL_WORLDS; do
			printf " $WORLD"
			updateServerSoftware $WORLD
			printf " Done.\n"
		done
		printf "\n"

		printf "Restarting Minecraft Server(s)..."
		for WORLD in $ALL_WORLDS; do
			printf "Starting $WORLD..."
			start $WORLD
			printf " Done.\n"
		done
		printf "Finished restarting server(s).\n"
		printf "=========\n"
		printf "Finished.\n"
	;;

	map|overviewer)
		# Make sure that the Minecraft Overviewer software exists.
		if [ ! -e "$OVERVIEWER_BIN" ]; then
			printf "Mincraft Overviewer software not found.\n"
			exit 1
		fi

		# figure out which worlds to map.
		WORLDS=$(checkOptionalArgument "$ALL_WORLDS" $0 $1 $2)

		# Run Minecraft Overviewer on each world requested.
		printf "Running Minecraft Overviewer mapping:"
		for WORLD in $WORLDS; do
			printf " $WORLD"
			if [ $(serverRunning $WORLD) -eq 1 ]; then
				sendCommand $WORLD "say The world is about to be mapped with Minecraft Overviewer."
				sendCommand $WORLD "save-all"
				sendCommand $WORLD "save-off"
				sleep 20
				worldBackup $WORLD
				overviewer $WORLD
				sendCommand $WORLD "save-on"
				sendCommand $WORLD "say Mapping is complete.  You can access the maps at:"
				sendCommand $WORLD "say $MAPS_URL/$WORLD"
			else
				worldBackup $WORLD
				overviewer $WORLD
			fi
		done
		printf "\n"
	;;
	*)
		echo "Minecraft Server Control Script"
		echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
		echo ""
		echo "Usage:"
		echo ""
		echo " NOTE: When [<world>] is the parameter, the command will work on/for the server work the given <world>, or all CONFIGured servers if no world is specified.  Nevertheless, a few commands are world-specific."
		echo ""
		echo "  start [<world>]: Start the server."
		echo "  watchstart <world>: Start the server, and switch to its screen to see the startup process in real time."
		echo "  stop [<world>]: Stop the server."
		echo "  force-stop [<world>]: Kill the server's running process."
		echo "  restart [<world>]: Stop and restart the server."
		echo "  scheduled-restart <world>: Stop and restart the server, giving warnings as far as 10 minutes in advance. (Intended to be auto-fired on a regular basis via cron, etc.)"
		echo "  force-restart [<world>]: Kill the server's running process and restart the server."
		echo "  powercycle [<world>]: Stop, back up, and restart the server. (NOTE: Backs up only the world files - essentially this combines \"restart\" and \"backup\".)"
		echo "  status [<world>]: View the server's current status (up or down), and player count if applicable."
		echo "  sync [<world>]: Sync the server's world files if mirroring is enabled."
		echo "  send <world> <command>: Send a single <command> to the server."
		echo "  screen <world>: Switch to the server's screen."
		echo "  watch <world>: Monitor the server by watching for server log changes."
		echo "  logrotate [<world>]: Rotate the server's log files."
		echo "  savetodisk [<world>]: Flush all pending world updates to disk - includes \"sync\" functionality if mirroring is enabled."
		echo "  backup [<world>]: Back up the server's world files. NOTE: This can take several minutes."
		echo "  fullbackup [<world>]: Back up the entire server. NOTE: This can take half an hour or more."
		echo "  update [<world>]: Update the server's jar file."
		echo "  map [<world>]: Redo the Overviewer map for the server, if Overviewer is installed."
		#printf "Usage: $0 {start|watchstart|stop|force-stop|restart|force-restart|status|sync|send|screen|watch|logrotate|savetodisk|backup|fullbackup|update|map} {Optional: world or software package}\n"
		exit 1
	;;
esac
exit 0
